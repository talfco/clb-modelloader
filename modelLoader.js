// Generated by CoffeeScript 1.4.0
(function() {
  var ModelLoader, mongoose, _und;

  _und = require("underscore");

  mongoose = require("mongoose");

  module.exports = ModelLoader = (function() {

    function ModelLoader(dbPath, version, winston, errDocUrl) {
      this.dbPath = dbPath;
      this.version = version;
      this.winston = winston;
      this.errDocUrl = errDocUrl;
      mongoose.connect(this.dbPath);
    }

    ModelLoader.prototype.autoload = function(serv, modelpath) {
      var files, fs, modelNames, path,
        _this = this;
      fs = require("fs");
      path = require("path");
      this.winston.info("Loading models from path " + modelpath);
      files = fs.readdirSync(modelpath);
      modelNames = _und.map(files, function(f) {
        return path.basename(f);
      });
      return _und.each(modelNames, function(modelName) {
        var model, modelC, suffix, suffix1;
        if (modelName !== void 0) {
          suffix = ".coffee";
          suffix1 = ".js";
          if (modelName.indexOf(suffix, modelName.length - suffix.length) !== -1 || modelName.indexOf(suffix1, modelName.length - suffix1.length) !== -1) {
            modelC = require(modelpath + "/" + modelName);
            _this.winston.info("Creating mogoose object for: " + modelName);
            model = new modelC({
              winston: _this.winston
            });
            return _this.expose(model, serv);
          }
        }
      });
    };

    ModelLoader.prototype.expose = function(model, serv) {
      var collection,
        _this = this;
      collection = model.getCollection();
      this.winston.info('ModelLoader: installing request handlers for /' + collection);
      serv.get('/' + this.version + '/' + collection, function(req, res) {
        var limC, limit, maxRec, projection, query, skipC;
        _this.winston.info('ModelLoader: GET for  ' + collection + ' received, sending the collection for ' + model.getDBModel().modelName);
        skipC = 0;
        projection = void 0;
        if (req.query["offset"] !== void 0) {
          skipC = parseInt(req.query["offset"]);
          _this.winston.info("Query Parameter 'offset' provided with value " + skipC);
          if (isNaN(skipC)) {
            _this.createJSONErrMsg(res, 400, 'Bad Request Query Parameter provided to the clb-modelloader API for "' + model.getCollection() + '": "offset" parameter is not at number', '0001', _this.errDocUrl + '0001');
            return;
          }
        }
        limit = model.getQueryLimit();
        if (req.query["limit"] !== void 0) {
          limC = parseInt(req.query["limit"]);
          _this.winston.info("Query Parameter 'limit' provided with value " + limC);
          if (isNaN(limC)) {
            _this.createJSONErrMsg(res, 400, 'Bad Request Query Parameter provided to the clb-modelloader API for "' + model.getCollection() + '": "limit" parameter is not at number', '0001', _this.errDocUrl + '0001');
            return;
          } else {
            if (limC < model.getQueryLimit()) {
              limit = limC;
            }
          }
        }
        if (req.query["fields"] !== void 0) {
          projection = {};
          _und.each(req.query["fields"].split(","), function(elem, index, list) {
            return projection[elem] = 1;
          });
          _this.winston.info("Got projection " + projection);
        }
        if (req.query["maxRec"] !== void 0) {
          _this.winston.info("No count query necessary");
          maxRec = parseInt(req.query["maxRec"]);
          _this.winston.info("Query Parameter 'maxRec' provided with value " + maxRec);
          if (isNaN(maxRec)) {
            _this.createJSONErrMsg(res, 400, 'Bad Request Query Parameter provided to the clb-modelloader API for "' + model.getCollection() + '": "maxRec" parameter is not at number', '0002', _this.errDocUrl + '0002');
            return;
          }
          return _this.getCollection(res, model, skipC, maxRec, projection, limit);
        } else {
          query = model.getDBModel().find({});
          return query.count(function(err, count) {
            _this.winston.info("Number of records " + count + " skip " + skipC);
            return _this.getCollection(res, model, skipC, count, projection, limit);
          });
        }
      });
      serv.get('/' + this.version + '/' + collection + '/:id', function(req, res) {
        var conditions;
        _this.winston.info('ModelLoader: GET received for ' + collection + '  model ' + req.params.id);
        conditions = {
          _id: req.params.id
        };
        return model.getDBModel().find(conditions, function(err, docs) {
          _this.winston.info("JSON Data", docs);
          if (err !== null) {
            return _this.createJSONErrMsg(res, 500, 'There was a technical error when requesting an entity "' + model.getCollection() + '":' + err, '0100', _this.errDocUrl + '0100');
          } else {
            return res.send(docs);
          }
        });
      });
      serv.put('/' + this.version + '/' + collection + '/:id', function(req, res) {
        var conditions, doc;
        _this.winston.info('ModelLoader: PUT received for model ' + req.params.id);
        _this.winston.info("JSON Data received ", req.body);
        conditions = {
          _id: req.params.id
        };
        doc = req.body;
        delete doc._id;
        return model.getDBModel().update(conditions, doc, {}, function(err, numAffected) {
          _this.winston.info('ModelLoader: Update done on ' + numAffected + " row - errors: " + err);
          if (err === null) {
            return res.send(doc);
          } else {
            return _this.createJSONErrMsg(res, 500, 'There was a technical error when updating an entity "' + model.getCollection() + '":' + err, '0100', _this.errDocUrl + '0100');
          }
        });
      });
      serv.del('/' + this.version + '/' + collection + '/:id', function(req, res) {
        var conditions;
        _this.winston.info('ModelLoader: DELETE received for model ' + req.params.id);
        conditions = {
          _id: req.params.id
        };
        return model.getDBModel().remove(conditions, function(err, numAffected) {
          _this.winston.info('ModelLoader: Delete done on ' + numAffected + " row - errors: " + err);
          if (err === null) {
            return res.json(200);
          } else {
            return res.json(err, 500);
          }
        });
      });
      return serv.post('/' + this.version + '/' + collection, function(req, res) {
        var conditions, dbModel, doc, obj;
        _this.winston.info('ModelLoader: POST received for model ' + collection);
        _this.winston.info("JSON Data received ", req.body);
        conditions = {
          _id: req.params.id
        };
        doc = req.body;
        _this.winston.info('ModelLoader: Creating new instance for ' + model.getModelName());
        dbModel = model.getDBModel();
        obj = new dbModel(doc);
        obj.save();
        _this.winston.info('ModelLoader: New record created');
        _this.winston.info(obj);
        return res.send(obj);
      });
    };

    ModelLoader.prototype.createJSONErrMsg = function(res, statusCode, usrMsg, errCode, moreInfo) {
      var errMsg;
      errMsg = {
        'message': usrMsg,
        'errorCode': errCode,
        'moreInfo': moreInfo
      };
      return res.json(errMsg, statusCode);
    };

    ModelLoader.prototype.getCollection = function(res, model, skipC, count, projection, limit) {
      var query,
        _this = this;
      this.winston.info("Got projection '" + projection + "'");
      query = model.getDBModel().find({}, projection).limit(limit).skip(skipC).sort({
        "_id": -1
      });
      return query.exec({}, function(err, docs) {
        var countStr, limitStr, skipStr;
        _this.winston.info("Fetched records with skip " + skipC);
        countStr = count + '';
        limitStr = limit + '';
        skipStr = skipC + '';
        docs.push({
          _maxRec: countStr,
          _limit: limitStr,
          _offset: skipStr
        });
        if (err !== null) {
          return _this.createJSONErrMsg(res, 500, 'There was a technical error when requesting entities "' + model.getCollection() + '":' + err, '0100', _this.errDocUrl + '0100');
        } else {
          return res.send(docs);
        }
      });
    };

    return ModelLoader;

  })();

}).call(this);
